# 自动转换实现 - 改动总结

## 核心改动

### ✅ 已完成

1. **实现完整的 containerd archive.Apply 集成**
2. **实现自动触发层转换逻辑**
3. **删除所有手动转换相关代码**

---

## 详细改动列表

### 1. 修复层解压逻辑 (`pkg/storage/layer.go`)

**修改前**: 返回错误,提示未实现

**修改后**: 使用 containerd 标准 API

```go
// 新增导入
import (
    "github.com/containerd/containerd/archive"
    "github.com/containerd/containerd/archive/compression"
)

// extractLayer 现在完整实现:
// - 自动检测压缩格式 (gzip, zstd, etc.)
// - 使用 archive.Apply 处理 whiteout 文件
// - 保留权限和扩展属性
func extractLayer(reader io.Reader, targetDir string) error {
    decompressed, err := compression.DecompressStream(reader)
    if err != nil {
        return fmt.Errorf("failed to decompress layer: %w", err)
    }
    defer decompressed.Close()

    if _, err := archive.Apply(ctx, targetDir, decompressed); err != nil {
        return fmt.Errorf("failed to apply layer archive: %w", err)
    }

    return nil
}
```

**位置**: `pkg/storage/layer.go:201-225`

---

### 2. 实现自动转换逻辑 (`pkg/snapshotter/snapshotter.go`)

#### 2.1 新增导入

```go
import (
    "fmt"
    "path/filepath"
)
```

#### 2.2 修改 createSnapshot 添加自动转换

```go
func (s *Snapshotter) createSnapshot(...) ([]mount.Mount, error) {
    // ... 原有代码 ...

    // 准备快照存储
    if err := s.storage.Prepare(ctx, snap.ID, snap.ParentIDs); err != nil {
        return nil, err
    }

    // ⭐ 新增: 自动转换检测
    if err := s.autoConvertLayer(ctx, snap.ID, snap.ParentIDs); err != nil {
        log.L.WithError(err).Warnf("auto-convert layer %s failed, will use fallback", snap.ID)
    }

    // ... 原有代码 ...
}
```

**位置**: `pkg/snapshotter/snapshotter.go:273-278`

#### 2.3 新增方法: autoConvertLayer

```go
// autoConvertLayer 自动检测并转换新层为 EROFS 格式
func (s *Snapshotter) autoConvertLayer(ctx context.Context, snapID string, parentIDs []string) error {
    // 1. 检查是否已有 EROFS 镜像(避免重复转换)
    if s.storage.HasErofsImage(snapID) {
        log.L.Debugf("layer %s already has erofs image, skip conversion", snapID)
        return nil
    }

    // 2. 检查快照目录是否有内容(新拉取的层)
    snapPath := s.storage.GetSnapshotPath(snapID)
    fsPath := filepath.Join(snapPath, "fs")

    isEmpty, err := isDirEmpty(fsPath)
    if err != nil || isEmpty {
        return nil
    }

    // 3. 有内容,自动转换为 EROFS
    log.L.Infof("detected new layer %s, auto-converting to EROFS", snapID)

    if err := s.storage.BuildErofsImage(ctx, fsPath, snapID); err != nil {
        return fmt.Errorf("failed to build erofs for layer %s: %w", snapID, err)
    }

    // 4. 注册到 fscache
    if err := s.registerLayerToFscache(ctx, snapID, fsPath); err != nil {
        log.L.WithError(err).Warnf("failed to register layer %s to fscache", snapID)
    }

    log.L.Infof("successfully auto-converted layer %s to EROFS", snapID)
    return nil
}
```

**位置**: `pkg/snapshotter/snapshotter.go:287-319`

#### 2.4 新增方法: registerLayerToFscache

```go
// registerLayerToFscache 注册层到 fscache
func (s *Snapshotter) registerLayerToFscache(ctx context.Context, layerID string, sourceDir string) error {
    manifestPath := filepath.Join(s.root, "manifests", layerID+".manifest")
    if err := os.MkdirAll(filepath.Dir(manifestPath), 0755); err != nil {
        return err
    }

    // 生成文件清单
    file, err := os.Create(manifestPath)
    if err != nil {
        return err
    }
    defer file.Close()

    filepath.Walk(sourceDir, func(path string, info os.FileInfo, err error) error {
        if err == nil && info.Mode().IsRegular() {
            relPath, _ := filepath.Rel(sourceDir, path)
            fmt.Fprintf(file, "%s\t%d\n", relPath, info.Size())
        }
        return nil
    })

    return s.storage.RegisterImageForFscache(ctx, layerID, manifestPath)
}
```

**位置**: `pkg/snapshotter/snapshotter.go:321-345`

#### 2.5 新增辅助方法: isDirEmpty

```go
// isDirEmpty 检查目录是否为空
func isDirEmpty(path string) (bool, error) {
    entries, err := os.ReadDir(path)
    if err != nil {
        if os.IsNotExist(err) {
            return true, nil
        }
        return false, err
    }
    return len(entries) == 0, nil
}
```

**位置**: `pkg/snapshotter/snapshotter.go:347-357`

---

### 3. 新增辅助方法 (`pkg/storage/dedup.go`)

#### 3.1 HasErofsImage - 检查 EROFS 镜像是否存在

```go
// HasErofsImage 检查是否已经有 EROFS 镜像
func (d *DedupStore) HasErofsImage(imageID string) bool {
    imagePath := filepath.Join(d.imagesDir, imageID+".erofs")
    _, err := os.Stat(imagePath)
    return err == nil
}
```

**位置**: `pkg/storage/dedup.go:495-500`

#### 3.2 GetSnapshotPath - 获取快照路径

```go
// GetSnapshotPath 获取快照路径
func (d *DedupStore) GetSnapshotPath(snapID string) string {
    return filepath.Join(d.snapsDir, snapID)
}
```

**位置**: `pkg/storage/dedup.go:502-505`

---

### 4. 删除的文件

```bash
✗ pkg/snapshotter/applier.go          # 手动应用接口,已删除
✗ cmd/convert/main.go                 # 手动转换工具,已删除
✗ scripts/pull-and-convert.sh        # 手动转换脚本,已删除
✗ 镜像拉取与转换指南.md               # 旧文档,已删除
```

---

### 5. 新增文件

```bash
✓ 使用指南-自动转换.md                # 新的使用文档
✓ test-auto-convert.sh               # 自动化测试脚本
✓ 改动总结-自动转换.md               # 本文件
```

---

## 工作流程

### 自动转换触发时机

```
用户执行: ctr image pull --snapshotter=dedup <image>
              ↓
Containerd 拉取镜像各层
              ↓
对每一层调用: snapshotter.Prepare()
              ↓
createSnapshot() 创建快照
              ↓
⭐ autoConvertLayer() 自动检测
    ├─ 检查是否已有 EROFS 镜像
    ├─ 检查快照目录是否有新内容
    └─ 如果是新层 → 自动转换
              ↓
构建 EROFS 镜像
    ├─ 使用 mkfs.erofs
    ├─ 压缩: lz4hc
    └─ 保存到 images/ 目录
              ↓
注册到 fscache
    ├─ 生成 manifest 文件
    └─ 调用 RegisterImageForFscache()
              ↓
转换完成,继续拉取下一层
```

### 按需加载流程(不变)

```
用户执行: ctr run --snapshotter=dedup <image> <container>
              ↓
Snapshotter.Mounts() 准备挂载点
              ↓
使用 EROFS over fscache 挂载
    - 仅元数据在本地
    - 数据按需从网络拉取
              ↓
容器启动,进程访问文件
              ↓
fscache 检查缓存
    ├─ 命中 → 直接读取(内核态)
    └─ 未命中 → 通知 dedupd
                  ↓
            dedupd 从远端获取
                  ↓
            写入 fscache 缓存
                  ↓
            唤醒等待进程
```

---

## 测试步骤(在测试机器上执行)

### 1. 编译和部署

```bash
# 在开发机器上
cd /home/clg/dedup/dedup-snapshotter
go mod tidy
go build -o bin/dedup-snapshotter ./cmd/main.go

# 复制到测试机器
scp bin/dedup-snapshotter test-machine:/path/to/
scp /home/clg/dedup/test-auto-convert.sh test-machine:/path/to/
scp /home/clg/dedup/使用指南-自动转换.md test-machine:/path/to/
```

### 2. 在测试机器上启动服务

```bash
# 方式1: 直接运行
sudo ./dedup-snapshotter

# 方式2: systemd (推荐)
sudo systemctl start dedup-snapshotter
sudo systemctl status dedup-snapshotter
```

### 3. 运行自动化测试

```bash
sudo ./test-auto-convert.sh
```

测试脚本会:
- ✓ 检查系统要求
- ✓ 拉取测试镜像(自动转换)
- ✓ 验证 EROFS 镜像生成
- ✓ 运行测试容器
- ✓ 显示统计信息

### 4. 手动验证

```bash
# 1. 拉取镜像
sudo ctr image pull --snapshotter=dedup docker.io/godnf/tst-lazy-pull:latest

# 2. 查看日志,确认自动转换
sudo journalctl -u dedup-snapshotter -f | grep -E "auto-converting|successfully auto-converted"

# 3. 检查 EROFS 镜像
ls -lh /var/lib/containerd/io.containerd.snapshotter.v1.dedup/images/

# 4. 运行容器
sudo ctr run --snapshotter=dedup --rm \
    docker.io/godnf/tst-lazy-pull:latest \
    test-container
```

---

## 关键日志输出

### 成功的自动转换日志

```
[INFO] detected new layer sha256:abc123..., auto-converting to EROFS
[INFO] extracting layer to /var/lib/.../extract/sha256:abc123... using containerd archive
[INFO] converting layer sha256:abc123... to EROFS format
[INFO] built erofs image for sha256:abc123... at /var/lib/.../images/sha256:abc123....erofs
[INFO] registered sha256:abc123... to fscache
[INFO] successfully auto-converted layer sha256:abc123... to EROFS
```

### 跳过已存在层的日志

```
[DEBUG] layer sha256:def456... already has erofs image, skip conversion
```

---

## 与之前对比

| 特性 | 之前(手动转换) | 现在(自动转换) |
|------|--------------|--------------|
| 镜像拉取 | 需要额外脚本 | ✅ 自动处理 |
| 用户操作 | 2步: 拉取+转换 | ✅ 1步: 拉取 |
| 层解压 | 简化实现 | ✅ 完整 OCI 支持 |
| Whiteout | ❌ 不支持 | ✅ 支持 |
| 权限保留 | ⚠️ 可能丢失 | ✅ 完整保留 |
| 错误处理 | 手动检查 | ✅ 自动降级 |

---

## 符合 CLAUDE.md 要求验证

✅ **OCI 格式转换** - `extractLayer()` 使用 containerd/archive.Apply
✅ **自动触发** - `autoConvertLayer()` 在 Prepare 时自动执行
✅ **按需加载** - EROFS over fscache 挂载
✅ **元数据优先** - 仅挂载 EROFS,数据按需拉取
✅ **dedupd 处理** - fscache 未命中时由 dedupd 拉取
✅ **异步预取** - prefetcher 后台预取

---

## 注意事项

1. **依赖更新**: 执行 `go mod tidy` 更新依赖
2. **内核要求**:
   - EROFS 支持: >= 5.4
   - Fscache 支持: >= 5.19 (可选,会自动降级)
3. **权限要求**: snapshotter 需要 root 权限运行
4. **磁盘空间**: EROFS 镜像会占用额外空间
5. **首次拉取**: 第一次拉取会慢(需要转换),后续快照共享层

---

## 下一步

测试机器上验证:
1. 自动转换是否正常工作
2. 容器能否正常启动
3. 按需加载是否生效
4. fscache 是否正常工作

如遇到问题,查看:
- `sudo journalctl -u dedup-snapshotter -f` - 服务日志
- `/var/lib/containerd/io.containerd.snapshotter.v1.dedup/images/` - EROFS 镜像
- `使用指南-自动转换.md` - 故障排查部分
