# dedup-snapshotter 代码架构分析：Fscache vs LazyLoader 模式

## 一、两种模式的实现状态

### 1. Fscache 模式实现 - 完整实现
- **状态**: 完全实现
- **位置**: `/home/clg/dedup/dedup-snapshotter/pkg/fscache/`
- **核心组件**:
  - `backend.go`: FScache 内核接口封装
  - `dedupd.go`: dedupd 守护进程（用户态服务）
  - `prefetch.go`: 异步预取管理器

### 2. LazyLoader 模式实现 - 完整实现
- **状态**: 完全实现
- **位置**: `/home/clg/dedup/dedup-snapshotter/pkg/lazy/loader.go`
- **特点**: 用户态懒加载实现

### 3. 内部通用 Loader 接口
- **位置**: `/home/clg/dedup/dedup-snapshotter/internal/lazy/loader.go`
- **特点**: 通用的加载器接口

---

## 二、两种模式的关键区别

### Fscache 模式
```
配置条件: useFscache = true
初始化代码 (pkg/storage/dedup.go L100-107):
    if useFscache {
        dedupDaemon, err := fscache.NewDedupDaemon(root, "", 4)
        store.dedupDaemon = dedupDaemon
    }

工作流程:
1. DedupStore 初始化时创建 DedupDaemon
2. DedupDaemon 初始化 fscache Backend（内核态）
3. 启动多个 downloadWorker（用户态工作线程）
4. 当镜像挂载时使用 MountErofsWithFscache

缓存管理:
- Backend: 直接与 /dev/cachefiles 交互
- Volume: 管理 fscache 卷
- CacheObject: 管理单个缓存对象
```

### LazyLoader 模式
```
配置条件: useFscache = false
初始化代码 (pkg/storage/dedup.go L109-114):
    } else {
        lazyLoader, err := lazy.NewLazyLoader(root, "")
        store.lazyLoader = lazyLoader
    }

工作流程:
1. DedupStore 初始化时创建 LazyLoader
2. LazyLoader 启动预取工作线程（prefetchWorkers）
3. 提供 LoadChunk 和 Prefetch 接口
4. 镜像使用普通 loop mount（MountErofs）

缓存管理:
- 本地文件系统缓存 (lazy-cache/)
- 内存中的 loadedChunks map
- HTTP 客户端从 Registry 直接下载
```

---

## 三、核心调用路径

### 挂载时的模式选择 (pkg/storage/dedup.go L179-226)

```go
func (d *DedupStore) mountsWithErofs(id string, parents []string) ([]mount.Mount, error) {
    // ...
    if d.useFscache && d.dedupDaemon != nil {
        // Fscache 模式
        fsid := parent
        domain := "dedup-snapshotter"
        mountPath, err = d.mountManager.MountErofsWithFscache(parent, fsid, domain)
    } else {
        // LazyLoader 模式 (fallback 或普通挂载)
        mountPath, err = d.mountManager.MountErofs(parent, imagePath)
    }
}
```

### 预取操作的模式选择

**Fscache 模式** (pkg/storage/dedup.go L337-343):
```go
func (d *DedupStore) StartPrefetch(ctx context.Context, imageID string, traceFile string) error {
    if !d.useFscache || d.dedupDaemon == nil {
        return fmt.Errorf("fscache not enabled")
    }
    return d.dedupDaemon.StartPrefetch(ctx, imageID, traceFile)
}
```

**LazyLoader 模式** (隐式使用):
- 预取由 LazyLoader 的 Prefetch 方法处理
- 但存储层没有直接调用此接口

---

## 四、配置管理

### 配置文件结构 (pkg/config/config.go)

```go
type Config struct {
    EnableErofs   bool          // 启用 EROFS 支持
    EnableFscache bool          // 启用 Fscache 模式
    EnableLazy    bool          // 启用 LazyLoader 模式
    // ...
    Dedupd        DedupdConfig  // Fscache 守护进程配置
    Prefetch      PrefetchConfig // 预取配置
}
```

### 默认值 (pkg/config/config.go L47-76)

```go
func DefaultConfig(root string) *Config {
    return &Config{
        EnableErofs:   true,   // 默认启用 EROFS
        EnableFscache: true,   // 默认启用 Fscache
        EnableLazy:    true,   // 默认启用 LazyLoader
        // ...
    }
}
```

---

## 五、初始化时的模式决策

### DedupStore 初始化逻辑 (pkg/storage/dedup.go L57-128)

```go
func NewDedupStoreWithOptions(root string, useErofs bool, useFscache bool) {
    if useErofs {
        // 初始化 EROFS
        store.erofsBuilder = builder
        store.mountManager = mountManager

        if useFscache {
            // Fscache 路径：初始化 DedupDaemon
            dedupDaemon, err := fscache.NewDedupDaemon(root, "", 4)
            store.dedupDaemon = dedupDaemon
        } else {
            // LazyLoader 路径：初始化 LazyLoader
            lazyLoader, err := lazy.NewLazyLoader(root, "")
            store.lazyLoader = lazyLoader
        }
    }
}
```

### 调用栈

```
cmd/main.go (main())
    ↓
snapshotter.NewSnapshotterWithAudit()
    ↓
storage.NewDedupStore()
    ↓
NewDedupStoreWithOptions(root, useErofs=true, useFscache=true/false)
    ├─ 如果 useFscache=true:
    │  └─ fscache.NewDedupDaemon()
    │      └─ fscache.NewBackend() → 初始化内核 fscache
    │
    └─ 如果 useFscache=false:
       └─ lazy.NewLazyLoader() → 初始化用户态加载器
```

---

## 六、关键文件位置汇总

### Fscache 模式文件
| 文件 | 功能 | 行数 |
|------|------|------|
| `/pkg/fscache/backend.go` | 内核 fscache 接口 | 311 行 |
| `/pkg/fscache/dedupd.go` | 守护进程核心 | 350 行 |
| `/pkg/fscache/prefetch.go` | 异步预取管理 | 306 行 |
| `/pkg/erofs/mount.go` | MountErofsWithFscache 方法 | L101-133 |

### LazyLoader 模式文件
| 文件 | 功能 | 行数 |
|------|------|------|
| `/pkg/lazy/loader.go` | 用户态懒加载器 | 273 行 |
| `/internal/lazy/loader.go` | 通用加载接口 | 72 行 |

### 存储层文件
| 文件 | 功能 |
|------|------|
| `/pkg/storage/dedup.go` | 模式选择逻辑（L100-114, L179-226) |
| `/pkg/config/config.go` | 配置管理 |

---

## 七、运行时行为差异

### Fscache 模式运行时流程
```
1. 容器启动 → snapshotter.Mounts()
2. 调用 storage.Mounts() 
3. 检查 d.useFscache && d.dedupDaemon != nil
4. 调用 MountErofsWithFscache(parent, fsid, domain)
   - 向 /dev/cachefiles 发送挂载命令
   - 使用 "fsid=parent,domain=dedup-snapshotter" 选项
5. dedupd 守护进程监听文件访问
6. 当 cache miss 时从 Registry 下载数据
7. 通过 fscache 写入内核缓存
```

### LazyLoader 模式运行时流程
```
1. 容器启动 → snapshotter.Mounts()
2. 调用 storage.Mounts()
3. 检查 d.useFscache && d.dedupDaemon != nil (为 false)
4. 调用 MountErofs(parent, imagePath)
   - 设置 loop 设备
   - 普通 mount -t erofs 
5. LazyLoader 在后台运行预取
6. 文件访问时从本地 lazy-cache 读取
7. 如果缓存缺失，则从 Registry 下载
```

---

## 八、结论

### 1. 两种模式是否共存？
**部分共存**：
- 配置上两个都开启（EnableFscache=true, EnableLazy=true）
- 但在运行时**只有一种生效**
- 由 `useFscache` 参数决定（L100 的 if 语句）
- LazyLoader 作为 fscache 的备选方案存在

### 2. 模式切换机制
- **显式切换**: 通过 `NewDedupStoreWithOptions()` 的 `useFscache` 参数
- **调用链**: snapshotter → storage.NewDedupStore() → NewDedupStoreWithOptions(useErofs=true, useFscache=**boolean**)
- **配置来源**: 目前代码中，useFscache 值硬编码为 `true`（见 L50）

### 3. 生产使用建议
- **Fscache 优先**: 内核态实现，性能更优
- **LazyLoader 备选**: 当 fscache 初始化失败时（L103）
- **挂载 fallback**: Fscache 挂载失败时自动降级到普通 mount（L193-194）

---

## 附录：关键代码片段

### 模式选择的完整决策树

```
NewDedupStore()
├─ NewDedupStoreWithOptions(root, useErofs=true, useFscache=true)
│  ├─ if useErofs {
│  │  ├─ erofsBuilder = NewBuilder()
│  │  ├─ mountManager = NewMountManager()
│  │  ├─ if useFscache {
│  │  │  ├─ dedupDaemon = NewDedupDaemon()  ← Fscache 模式初始化
│  │  │  │  └─ backend = NewBackend()
│  │  │  │     └─ syscall.Open("/dev/cachefiles")  ← 内核交互
│  │  │  └─ 启动 downloadWorkers (用户态进程)
│  │  │
│  │  └─ else {
│  │     ├─ lazyLoader = NewLazyLoader()  ← LazyLoader 模式初始化
│  │     └─ 启动 prefetchWorkers (用户态进程)
│  │
│  └─ memDedup = NewMemoryDeduplicator()

运行时调用:
Mounts(id, parents)
├─ if useErofs && mountManager != nil {
│  ├─ if useFscache && dedupDaemon != nil {
│  │  └─ MountErofsWithFscache()  ← Fscache 模式挂载
│  │     └─ mount -t erofs -o "ro,fsid=...,domain=..."
│  │
│  └─ else {
│     └─ MountErofs()  ← LazyLoader 模式挂载
│        └─ mount -t erofs via loopback
│
└─ (使用 overlay 创建容器挂载点)
```


---

## 九、代码交叉引用详解

### A. DedupStore 初始化完整流程

**第一步：NewDedupStore() [pkg/storage/dedup.go:49-51]**
```go
func NewDedupStore(root string) (*DedupStore, error) {
    return NewDedupStoreWithOptions(root, true, true)
    // 传入 useErofs=true, useFscache=true
}
```

**第二步：NewDedupStoreWithOptions() [pkg/storage/dedup.go:57-128]**
```go
// 关键初始化块 (L100-114)
if useFscache {
    // 初始化 Fscache 模式
    dedupDaemon, err := fscache.NewDedupDaemon(root, "", 4)
    if err != nil {
        log.L.Warnf("failed to create dedupd daemon: %v", err)
        // 注意：这里只是 warn，不会导致初始化失败
    } else {
        store.dedupDaemon = dedupDaemon
        log.L.Info("dedupd daemon initialized for fscache support")
    }
} else {
    // 初始化 LazyLoader 模式
    lazyLoader, err := lazy.NewLazyLoader(root, "")
    if err != nil {
        return nil, fmt.Errorf("failed to create lazy loader: %w", err)
        // 注意：这里是 error，会导致初始化失败
    }
    store.lazyLoader = lazyLoader
}
```

**关键观察**：
- Fscache 初始化失败只是 warn，不会影响整体初始化
- LazyLoader 初始化失败会导致整体初始化失败
- 这表明 Fscache 是"可选的优化"，而 LazyLoader 是"后备方案"

---

### B. 挂载时的模式选择详解

**pkg/storage/dedup.go L188-198 - 挂载决策**
```go
if d.useFscache && d.dedupDaemon != nil {
    // Fscache 模式：尝试使用内核 fscache
    fsid := parent
    domain := "dedup-snapshotter"
    mountPath, err = d.mountManager.MountErofsWithFscache(parent, fsid, domain)
    
    if err != nil {
        // Fscache 挂载失败时自动降级
        log.L.Warnf("fscache mount failed, falling back to loop mount: %v", err)
        mountPath, err = d.mountManager.MountErofs(parent, imagePath)
    }
} else {
    // 直接使用 loop mount（LazyLoader 模式或禁用 Fscache）
    mountPath, err = d.mountManager.MountErofs(parent, imagePath)
}
```

**执行路径分析**：
| 条件 | 挂载方式 | 预取方式 |
|------|---------|---------|
| useFscache=true, dedupDaemon≠nil | MountErofsWithFscache | dedupd workers |
| MountErofsWithFscache 失败 | MountErofs (fallback) | dedupd workers |
| useFscache=false | MountErofs | LazyLoader prefetch |

---

### C. DedupDaemon 内核交互详解

**pkg/fscache/dedupd.go L62-93 - 初始化**
```go
func NewDedupDaemon(root, registry string, workers int) (*DedupDaemon, error) {
    // 第1步：初始化 fscache Backend（直接与内核通信）
    backend, err := NewBackend(root)
    // NewBackend 会：
    // 1. 创建 /var/cache/fscache 目录
    // 2. syscall.Open("/dev/cachefiles") 打开内核接口
    // 3. 发送 "bind" 命令将缓存目录与 fscache 绑定
    
    // 第2步：启动工作线程
    daemon.startWorkers()
    // 为每个 worker 启动 downloadWorker goroutine
}
```

**pkg/fscache/backend.go L45-80 - Backend 初始化**
```go
func NewBackend(root string) (*Backend, error) {
    // 检查内核支持
    if err := ensureFsCacheAvailable(); err != nil {
        return nil, err  // /sys/fs/fscache 必须存在
    }
    
    // 打开 cachefiles 设备驱动
    fd, err := syscall.Open(CachefilesPath, syscall.O_RDWR, 0)
    // CachefilesPath = "/dev/cachefiles"
    
    // 将缓存目录与 fscache 绑定
    backend.bindCache()
    // 向 fd 写入 "bind /var/cache/fscache" 命令
}
```

---

### D. 预取流程对比

#### Fscache 预取 [pkg/fscache/prefetch.go]
```
StartPrefetch(ctx, imageInfo, traceFile)
  ├─ loadTraceFile() 读取访问模式
  ├─ runPrefetchJob() 运行预取任务
  │  └─ for each chunk in traces:
  │     ├─ prefetchChunk() 为每个 chunk 创建下载任务
  │     │  └─ daemon.EnqueueDownload(task)
  │     └─ updatePredictor() 更新访问模式预测器
  │
  └─ downloadWorker() [在后台运行]
     └─ for each task:
        ├─ task.Volume.CreateObject() 在 fscache 中创建对象
        ├─ fetchChunkData() 从 Registry 下载数据
        ├─ obj.Write() 写入 fscache 缓存文件
        └─ obj.MarkComplete() 标记完成
```

#### LazyLoader 预取 [pkg/lazy/loader.go]
```
Prefetch(imageID, chunkHashes)
  └─ for each hash:
     ├─ task = PrefetchTask{ChunkHash, Priority, ImageID}
     └─ prefetchQueue.queue <- task

prefetchWorker() [在后台运行]
  └─ for each task:
     ├─ loadChunk(ctx, chunkHash, imageID)
     │  ├─ fetchChunk() 从 Registry 下载
     │  └─ os.Rename() 保存到 lazy-cache/
     └─ updateLoadedChunks()
```

**关键差异**：
- Fscache: 数据写入内核 fscache，多个进程共享，零拷贝访问
- LazyLoader: 数据写入本地文件系统，每个进程可能重复加载

---

### E. 清理和关闭流程

**pkg/storage/dedup.go L297-335 - Close() 方法**
```go
func (d *DedupStore) Close() error {
    var errs []error
    
    // 关闭 Fscache 守护进程
    if d.dedupDaemon != nil {
        if err := d.dedupDaemon.Shutdown(context.Background()); err != nil {
            errs = append(errs, err)
        }
    }
    
    // 关闭 LazyLoader
    if d.lazyLoader != nil {
        if err := d.lazyLoader.Cleanup(); err != nil {
            errs = append(errs, err)
        }
    }
    
    // 其他清理...
}
```

**pkg/fscache/dedupd.go L325-343 - DedupDaemon.Shutdown()**
```go
func (d *DedupDaemon) Shutdown(ctx context.Context) error {
    // 1. 停止下载工作线程
    d.cancel()
    d.wg.Wait()
    
    // 2. 关闭下载队列
    close(d.downloadQueue)
    
    // 3. 停止预取器
    if d.prefetcher != nil {
        d.prefetcher.Stop()
    }
    
    // 4. 关闭 fscache backend
    if d.backend != nil {
        return d.backend.Close()
    }
}
```

---

## 十、模式选择的决策因素

### 什么时候选择 Fscache 模式？
```
✓ 内核版本 >= 5.15（支持 erofs over fscache）
✓ /dev/cachefiles 可用（cachefiles 模块已加载）
✓ 需要跨容器共享镜像缓存
✓ 追求最高性能（零拷贝）
✓ 有足够的页面缓存预算
```

### 什么时候选择 LazyLoader 模式？
```
✓ 内核版本 < 5.15
✓ cachefiles 不可用
✓ Fscache 初始化失败
✓ 需要更灵活的缓存控制
✓ 容器之间共享缓存不是优先级
```

### 当前代码的选择
```go
// 默认优先选择 Fscache
useErofs := true
useFscache := true

// 如果 Fscache 初始化失败，仍然继续运行
// （因为 LazyLoader 作为备选初始化成功了）

// 如果挂载 Fscache 失败，自动降级到 loop mount
```

---

## 十一、性能影响分析

### Fscache 模式
| 方面 | 性能特征 |
|------|---------|
| 缓存命中 | 零拷贝，内核直接访问 |
| 缓存写入 | 预取写入内核缓存 |
| 多容器 | 自动共享页面缓存（COW）|
| 内存占用 | 由 VM 管理页面缓存 |
| CPU 开销 | 最低（内核处理） |

### LazyLoader 模式
| 方面 | 性能特征 |
|------|---------|
| 缓存命中 | VFS 通过 page cache |
| 缓存写入 | 用户态 HTTP 下载 + 文件 I/O |
| 多容器 | 文件系统级别共享（需同步挂载） |
| 内存占用 | 用户态缓存 + page cache 双计算 |
| CPU 开销 | 较高（多次上下文切换） |

---

## 十二、当前实现的问题和改进空间

### 问题 1：硬编码的模式选择
**位置**: pkg/storage/dedup.go L50
```go
// 当前代码
func NewDedupStore(root string) (*DedupStore, error) {
    return NewDedupStoreWithOptions(root, true, true)  // 硬编码 useFscache=true
}
```
**改进**: 应该从配置文件读取 EnableFscache 标志

### 问题 2：LazyLoader 被隐式初始化
**位置**: pkg/storage/dedup.go L109
```go
// 当前代码总是初始化 LazyLoader
// 即使 useFscache=true 也会创建（但不使用）
```
**改进**: 应该根据配置决定是否初始化 LazyLoader

### 问题 3：配置值未被使用
**位置**: pkg/config/config.go, 但在 dedup.go 中没有使用
```go
// 配置中定义了
EnableFscache bool  // 但 dedup.go 中硬编码为 true
EnableLazy    bool  // 但 dedup.go 中硬编码为 false
```

### 问题 4：两个预取接口不一致
**Fscache**: 
```go
StartPrefetch(ctx, imageID, traceFile) error
```
**LazyLoader**: 
```go
Prefetch(imageID, chunkHashes) 
PrefetchWithTrace(imageID, traceFile) error
```
**改进**: 应该统一接口或提供通用的预取抽象

---

## 十三、快速查找指南

### 我想找...
| 需求 | 位置 |
|------|------|
| Fscache 配置 | `/pkg/fscache/backend.go` L14-18 |
| Fscache 工作线程 | `/pkg/fscache/dedupd.go` L102-125 |
| 内核交互代码 | `/pkg/fscache/backend.go` L112-121 |
| LazyLoader 实现 | `/pkg/lazy/loader.go` L16-67 |
| 模式决策代码 | `/pkg/storage/dedup.go` L100-114 |
| 挂载选择代码 | `/pkg/storage/dedup.go` L188-198 |
| 预取管理 | `/pkg/fscache/prefetch.go` L62-92 |
| 配置定义 | `/pkg/config/config.go` L12-76 |

