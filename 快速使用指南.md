# Dedup-Snapshotter 快速使用指南

## 核心工作原理

### 镜像拉取和按需加载流程

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 用户执行: ctr image pull --snapshotter=dedup nginx:latest│
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. Containerd 从 Registry 拉取镜像 manifest 和 layer 信息    │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. Dedup-Snapshotter 接收层数据                              │
│    - 对每一层进行块级切分 (4MB)                               │
│    - 计算每个块的 SHA256 哈希                                 │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. 块级去重处理                                              │
│    - 查询 index.db: 块是否已存在?                            │
│    - 已存在: 增加引用计数 ref_count++                        │
│    - 不存在: 存储到 chunks/ 目录,插入数据库记录               │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. 构建 EROFS 只读镜像                                        │
│    - 使用 mkfs.erofs 构建镜像文件                            │
│    - 存储到 images/<image-id>.erofs                          │
│    - 使用 LZ4HC 压缩优化                                      │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. 容器启动时挂载 (按需加载开始)                             │
│    模式A: Fscache 模式 (内核 5.15+)                          │
│      - 注册镜像到 fscache                                     │
│      - 文件访问时内核自动从 Registry 下载块                   
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 7. 容器运行                                                  │
│    - 只下载容器实际访问的文件块                               │
│    - 其他数据块不下载,节省带宽和时间                          │
│    - KSM 进行内存页面级去重                                   │
└─────────────────────────────────────────────────────────────┘
```

---

## 一分钟快速启动

### 1. 构建安装
```bash
cd /home/clg/dedup/dedup-snapshotter
sudo make install
```

### 2. 配置 containerd
编辑 `/etc/containerd/config.toml`:
```toml
[proxy_plugins]
  [proxy_plugins.dedup]
    type = "snapshot"
    address = "/run/containerd/dedup-snapshotter.sock"
```

### 3. 启动服务
```bash
sudo systemctl restart containerd
sudo systemctl start dedup-snapshotter
sudo systemctl status dedup-snapshotter
```

### 4. 拉取镜像
```bash
# 使用 dedup snapshotter 拉取镜像
sudo ctr image pull --snapshotter=dedup docker.io/library/nginx:latest

# 查看快照
sudo ctr snapshot ls --snapshotter=dedup
```

### 5. 运行容器
```bash
# 启动容器 (按需加载生效)
sudo ctr run --snapshotter=dedup --rm -t docker.io/library/nginx:latest test-nginx /bin/sh
```

---

## 关键数据流详解

### 数据去重工作机制

#### 块级去重示例

假设拉取两个镜像 ubuntu:20.04 和 ubuntu:22.04:

```
ubuntu:20.04 layer1:
  ├─ file1.txt (6MB) → 切分为 2个块
  │   ├─ chunk1 (4MB) → hash: abc123...
  │   └─ chunk2 (2MB) → hash: def456...
  └─ file2.bin (4MB) → hash: ghi789...

ubuntu:22.04 layer1:
  ├─ file1.txt (6MB) → 相同文件!
  │   ├─ chunk1 (4MB) → hash: abc123... (已存在,ref_count: 1→2)
  │   └─ chunk2 (2MB) → hash: def456... (已存在,ref_count: 1→2)
  └─ file3.bin (4MB) → hash: jkl012... (新块,存储)
```

**去重效果:**
- 不使用去重: 14MB (6+4+6+4)
- 使用去重: 10MB (6+4+4,复用 6MB)
- 节省: 28.5%

#### 数据库结构

`index.db` 中的数据表:

```sql
-- 数据块索引表
CREATE TABLE chunks (
    hash TEXT PRIMARY KEY,      -- SHA256 哈希
    size INTEGER,               -- 块大小
    ref_count INTEGER DEFAULT 1 -- 引用计数
);

-- 文件到块的映射
CREATE TABLE files (
    path TEXT PRIMARY KEY,      -- 文件路径
    chunks TEXT                 -- 块哈希列表 (逗号分隔)
);
```

---

## 按需加载性能对比

### 场景：启动一个大型镜像的容器,只执行简单命令

#### 传统方式 (Docker pull)
```
1. 下载完整镜像: 2GB
2. 解压所有层: 30秒
3. 启动容器: 2秒
总时间: ~35秒 (取决于网络)
```

#### Dedup-Snapshotter (按需加载)
```
1. 下载 manifest: 0.5秒
2. 构建 EROFS 镜像元数据: 1秒
3. 启动容器: 2秒
4. 按需下载必需文件 (约100MB): 3秒
总时间: ~6.5秒
```

**加速比: 5.4x**

---

## 测试验证步骤

### 冷启动加速验证

#### 步骤1: 清理环境
```bash
# 清理所有镜像
sudo ctr image rm $(sudo ctr image ls -q) && sudo docker image prune -a -f

# 清理 snapshotter 数据
sudo rm -rf /var/lib/containerd/io.containerd.snapshotter.v1.dedup/*
sudo systemctl restart dedup-snapshotter
```

#### 步骤2: 传统方式测试
```bash
# 记录开始时间
echo "开始时间: $(date +%s.%N)"

# 拉取并运行
sudo docker pull godnf/tst-lazy-pull:latest
time sudo docker run --rm godnf/tst-lazy-pull:latest /bin/sh -c "md5sum /path/to/test/file"

# 记录结束时间
echo "结束时间: $(date +%s.%N)"
```

#### 步骤3: 按需加载测试
```bash
# 清理缓存
sudo ctr image rm docker.io/godnf/tst-lazy-pull:latest

# 启动资源监控
bash /home/clg/dedup/monitor_resource.sh  > /home/clg/dedup/res/dedup_test.log &
MONITOR_PID=$!

# 记录开始时间
echo "开始时间: $(date +%s.%N)"

# 使用 dedup snapshotter
sudo ctr image pull --snapshotter=dedup docker.io/godnf/tst-lazy-pull:latest
time sudo ctr run --snapshotter=dedup --rm docker.io/godnf/tst-lazy-pull:latest test-container /bin/sh -c "md5sum /path/to/test/file"

# 记录结束时间
echo "结束时间: $(date +%s.%N)"

# 停止监控
kill $MONITOR_PID
```

#### 步骤4: 分析结果
```bash
# 查看去重效果
sudo sqlite3 /var/lib/containerd/io.containerd.snapshotter.v1.dedup/index.db \
  "SELECT COUNT(*) as total_chunks, SUM(size) as total_size FROM chunks;"

# 查看引用计数
sudo sqlite3 /var/lib/containerd/io.containerd.snapshotter.v1.dedup/index.db \
  "SELECT ref_count, COUNT(*) FROM chunks GROUP BY ref_count;"

# 查看实际下载的数据量 (通过审计日志)
sudo sqlite3 /var/lib/containerd/io.containerd.snapshotter.v1.dedup/audit.db \
  "SELECT operation, result, COUNT(*) FROM audit_logs GROUP BY operation, result;"
```

---

## 关键指标监控

### 1. 存储节省率
```bash
# 计算去重后的存储节省
TOTAL_CHUNKS=$(sudo sqlite3 /var/lib/containerd/io.containerd.snapshotter.v1.dedup/index.db \
  "SELECT SUM(size * ref_count) FROM chunks;")
ACTUAL_SIZE=$(sudo sqlite3 /var/lib/containerd/io.containerd.snapshotter.v1.dedup/index.db \
  "SELECT SUM(size) FROM chunks;")

echo "不去重大小: $TOTAL_CHUNKS bytes"
echo "去重后大小: $ACTUAL_SIZE bytes"
echo "节省率: $(echo "scale=2; (1 - $ACTUAL_SIZE / $TOTAL_CHUNKS) * 100" | bc)%"
```

### 2. 内存去重效果 (KSM)
```bash
# 查看 KSM 统计
cat /sys/kernel/mm/ksm/pages_sharing    # 共享的页面数
cat /sys/kernel/mm/ksm/pages_shared     # 合并的页面数
cat /sys/kernel/mm/ksm/pages_unshared   # 未共享的页面数

# 计算内存节省
SHARED_PAGES=$(cat /sys/kernel/mm/ksm/pages_sharing)
PAGE_SIZE=4096  # 4KB
MEMORY_SAVED=$((SHARED_PAGES * PAGE_SIZE))
echo "内存节省: $(echo "scale=2; $MEMORY_SAVED / 1024 / 1024" | bc) MB"
```

### 3. 按需加载统计
```bash
# 通过日志查看预取统计
sudo journalctl -u dedup-snapshotter | grep "prefetch"

# API 查询统计信息
curl http://localhost:8080/stats
```

---

## 常见问题快速修复

### 问题: EROFS 挂载失败
```bash
# 加载 erofs 模块
sudo modprobe erofs

# 检查是否成功
lsmod | grep erofs
```

### 问题: 找不到 mkfs.erofs
```bash
# CentOS
sudo yum install -y erofs-utils

# Ubuntu
sudo apt-get install -y erofs-utils
```

### 问题: containerd 无法识别 snapshotter
```bash
# 检查 socket
ls -l /run/containerd/dedup-snapshotter.sock

# 检查 containerd 配置
sudo cat /etc/containerd/config.toml | grep -A 5 proxy_plugins

# 重启服务
sudo systemctl restart dedup-snapshotter
sudo systemctl restart containerd
```

### 问题: KSM 未启用
```bash
# 手动启用
echo 1 | sudo tee /sys/kernel/mm/ksm/run

# 检查状态
cat /sys/kernel/mm/ksm/run
```

---

## 与传统 Overlay2 的对比

| 特性 | Overlay2 | Dedup-Snapshotter |
|------|----------|-------------------|
| 存储去重 | 仅层级去重 | 块级去重 (4MB) |
| 内存去重 | 无 | KSM 页面级去重 |
| 按需加载 | 需全量下载 | 支持 fscache/LazyLoader |
| 冷启动速度 | 慢 (需下载全部) | 快 (只下载必需) |
| 文件系统 | Overlay | EROFS (只读,压缩) |
| 跨镜像去重 | 不支持 | 支持 |
| 存储占用 | 高 | 低 (节省 30-60%) |
| 内存占用 | 高 | 低 (KSM合并) |

---

## 生产环境推荐配置

```json
{
  "root": "/var/lib/containerd/io.containerd.snapshotter.v1.dedup",
  "enable_erofs": true,
  "enable_fscache": true,
  "enable_lazy": true,
  "enable_mem_dedup": true,
  "chunk_size": 4194304,
  "log_level": "info",
  "prefetch": {
    "enabled": true,
    "workers": 8,
    "queue_size": 2000,
    "trace_dir": "/var/lib/containerd/io.containerd.snapshotter.v1.dedup/traces"
  },
  "ksm": {
    "enabled": true,
    "scan_interval": 100,
    "pages_to_scan": 200,
    "merge_across_nodes": false
  },
  "dedupd": {
    "enabled": true,
    "workers": 8,
    "registry": "https://registry-1.docker.io",
    "fscache_domain": "dedup-snapshotter"
  }
}
```

**调优建议:**
- **CPU 核心多**: 增加 `prefetch.workers` 和 `dedupd.workers`
- **内存充足**: 增加 `prefetch.queue_size` 和 `ksm.pages_to_scan`
- **网络快**: 增加 `dedupd.workers` 提升并发下载
- **SSD 存储**: 可以适当增加 `chunk_size` 到 8MB

---

## 总结

Dedup-Snapshotter 通过以下技术实现容器启动加速和存储优化:

1. **块级去重**: 跨镜像、跨层的数据块复用
2. **EROFS**: 只读文件系统,压缩优化
3. **按需加载**: 只下载容器实际需要的数据
4. **内存去重**: KSM 内核模块合并相同内存页
5. **智能预取**: 基于访问追踪的数据预取

适用场景:
- 大规模容器集群部署
- 镜像仓库存储优化
- 边缘计算节点 (带宽受限)
- 快速扩容场景 (大量新节点)
- CI/CD 环境 (频繁构建和部署)
