# 容器冷启动全流程图 - 包含数据去重、按需加载时序逻辑

## 系统架构概览

```mermaid
graph TB
    subgraph "容器冷启动全流程"
        A[容器启动请求] --> B{镜像层是否存在?}
        B -->|否| C[从Registry拉取镜像]
        B -->|是| D[检查本地存储]

        C --> E[镜像层处理]
        D --> E

        subgraph "数据去重处理"
            E --> F[块级分割 4MB]
            F --> G[计算SHA256哈希]
            G --> H{块是否已存在?}
            H -->|是| I[增加引用计数]
            H -->|否| J[存储新块]
            I --> K[更新索引数据库]
            J --> K
        end

        subgraph "EROFS镜像构建"
            K --> L[构建EROFS镜像]
            L --> M[压缩优化 LZ4HC]
            M --> N[生成镜像元数据]
        end

        subgraph "按需加载机制"
            N --> O{使用fscache?}
            O -->|是| P[初始化fscache后端]
            O -->|否| Q[使用LazyLoader]

            P --> R[注册镜像到fscache]
            Q --> S[设置预取队列]

            R --> T[创建挂载点]
            S --> T

            T --> U[解析访问追踪文件]
            U --> V[启动预取任务]
        end

        subgraph "内存去重"
            V --> W[启动KSM内核模块]
            W --> X[页面级内存去重]
            X --> Y[madvise MADV_MERGEABLE]
        end

        subgraph "容器文件系统挂载"
            Y --> Z[创建Overlay挂载]
            Z --> AA[设置lowerdir/upperdir/workdir]
            AA --> BB[完成容器启动]
        end
    end
```

## 详细时序流程

### 1. 冷启动初始化阶段

```mermaid
sequenceDiagram
    participant C as Containerd
    participant S as DedupSnapshotter
    participant DS as DedupStore
    participant IDB as IndexDB
    participant EB as ErofsBuilder

    C->>S: Prepare(key, parent)
    S->>DS: Prepare(id, parents)
    DS->>DS: 创建snapshot目录
    DS->>IDB: 验证数据库完整性
    IDB->>IDB: PRAGMA integrity_check
    DS->>S: 返回准备完成
    S->>C: 返回准备结果
```

### 2. 镜像层处理与数据去重

```mermaid
sequenceDiagram
    participant DS as DedupStore
    participant EB as ErofsBuilder
    participant CI as ChunkIndexer
    participant IDB as IndexDB

    Note over DS,IDB: 镜像层数据处理阶段

    DS->>EB: BuildImage(sourceDir, imageID)
    EB->>EB: 遍历源目录文件

    loop 对每个文件进行处理
        EB->>EB: 判断文件大小
        alt 文件 < 4MB
            EB->>EB: 直接复制小文件
        else 文件 >= 4MB
            EB->>EB: 分割为4MB块
            EB->>EB: 计算SHA256哈希
            EB->>CI: RecordChunk(imageID, hash, size)
            CI->>IDB: 检查块是否存在
            alt 块已存在
                IDB->>IDB: 增加引用计数
            else 块不存在
                EB->>EB: 存储块到chunks目录
                IDB->>IDB: 插入新块记录
            end
        end
    end

    EB->>EB: 执行mkfs.erofs构建镜像
    EB->>DS: 返回镜像路径
```

### 3. 按需加载与预取机制

```mermaid
sequenceDiagram
    participant MM as MountManager
    participant FC as FscacheBackend
    participant DD as DedupDaemon
    participant PF as Prefetcher
    participant LL as LazyLoader

    Note over MM,LL: 按需加载启动阶段

    alt 使用fscache模式
        MM->>FC: 创建Volume
        FC->>FC: 初始化cachefiles设备
        MM->>DD: 注册镜像到daemon
        DD->>PF: 启动预取任务

        loop 预取循环
            PF->>PF: 解析trace文件
            PF->>DD: EnqueueDownload(task)
            DD->>FC: 下载块到fscache
            FC->>FC: 标记对象完成
        end

        MM->>MM: 使用fscache挂载EROFS
    else 使用LazyLoader模式
        MM->>LL: 创建LazyLoader
        LL->>LL: 启动预取工作线程

        loop 懒加载循环
            LL->>LL: 监听块访问请求
            LL->>LL: 检查本地缓存
            alt 块不存在
                LL->>LL: 从Registry拉取块
                LL->>LL: 存储到本地缓存
            end
        end

        MM->>MM: 使用loop设备挂载EROFS
    end
```

### 4. 内存去重机制

```mermaid
sequenceDiagram
    participant MD as MemoryDeduplicator
    participant KSM as KSMController
    participant OS as 操作系统

    Note over MD,OS: 内存去重阶段

    MD->>KSM: EnableKSM()
    KSM->>OS: echo 1 > /sys/kernel/mm/ksm/run

    loop 文件内存映射去重
        MD->>MD: DeduplicateFile(filePath)
        MD->>OS: mmap文件到内存
        MD->>MD: 按页面处理(4KB)

        loop 每个页面
            MD->>MD: 计算页面SHA256哈希
            alt 页面已存在
                MD->>MD: 增加引用计数
                MD->>MD: 记录内存节省
            else 新页面
                MD->>MD: 添加到页面映射
            end
        end

        MD->>OS: madvise(MADV_MERGEABLE)
        OS->>OS: 标记页面可合并
    end

    KSM->>OS: 后台扫描合并相同页面
```

### 5. 容器挂载与启动完成

```mermaid
sequenceDiagram
    participant S as Snapshotter
    participant MM as MountManager
    participant DS as DedupStore
    participant MD as MemoryDeduplicator
    participant C as Containerd

    Note over S,C: 最终挂载阶段

    C->>S: Mounts(key)
    S->>DS: Mounts(id, parents)

    alt 使用EROFS
        DS->>MM: mountsWithErofs(id, parents)

        loop 处理每个parent层
            MM->>MM: 检查EROFS镜像是否存在
            alt 镜像存在
                alt 使用fscache
                    MM->>MM: MountErofsWithFscache()
                else 使用loop设备
                    MM->>MM: MountErofs()
                end
                MM->>MD: 启动内存去重
                activate MD
                MD->>MD: 遍历挂载点文件
                MD->>MD: DeduplicateFile()
                deactivate MD
            else 镜像不存在
                MM->>MM: 使用传统overlay目录
            end
        end

        MM->>MM: CreateOverlayMounts()
    else 使用传统overlay
        DS->>DS: mountsWithOverlay()
        DS->>DS: 设置lowerdir/upperdir/workdir
    end

    DS->>S: 返回mount配置
    S->>C: 返回挂载点
    C->>C: 完成容器启动
```

## 核心数据结构与存储

### 去重数据索引结构
```sql
-- 块级去重索引表
CREATE TABLE chunks (
    hash TEXT PRIMARY KEY,      -- SHA256哈希值
    size INTEGER,              -- 块大小
    ref_count INTEGER DEFAULT 1 -- 引用计数
);

-- 文件到块的映射表
CREATE TABLE files (
    path TEXT PRIMARY KEY,      -- 文件路径
    chunks TEXT                -- 块哈希列表(逗号分隔)
);
```

### 预取追踪数据格式
```
# trace文件格式示例
chunk_hash_1
chunk_hash_2
chunk_hash_3
...
```

## 关键性能优化点

1. **块级去重**: 4MB块大小平衡去重率和性能
2. **EROFS压缩**: LZ4HC算法提供高效压缩比
3. **Fscache集成**: 内核级缓存减少用户态开销
4. **预取策略**: 基于访问模式的智能预测
5. **内存去重**: KSM内核模块页面级合并
6. **并发控制**: 多线程预取和索引操作
7. **崩溃恢复**: WAL日志和完整性检查机制

## 故障处理与恢复

1. **数据库恢复**: 检测锁文件和WAL文件状态
2. **引用计数修复**: 重建索引维护数据一致性
3. **快照验证**: 元数据和文件系统完整性检查
4. **优雅降级**: fscache失败时回退到loop挂载

这个流程图详细展示了dedup-snapshotter的容器冷启动全过程，包含了数据去重、按需加载的完整时序逻辑和核心实现机制。