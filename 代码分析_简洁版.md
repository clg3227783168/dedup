# 代码探索总结

## 核心发现

### 1. 两种模式是否共存？

**答案：是的，但仅在编译时共存。运行时只有一种生效。**

- 代码中同时实现了两种完整的模式
- 配置文件定义了两个开关（EnableFscache、EnableLazy）
- **但在运行时，通过 `useFscache` 布尔参数做出排他性选择**

### 2. 实现位置总结

| 模式 | 核心文件 | 文件数量 | 总代码行数 |
|------|--------|--------|---------|
| **Fscache** | `/pkg/fscache/` | 3个文件 | ~967行 |
| **LazyLoader** | `/pkg/lazy/` + `/internal/lazy/` | 2个文件 | ~345行 |
| **模式选择** | `/pkg/storage/dedup.go` | 1个文件 | L100-114 决策 |

### 3. 调用关系图

```
启动流程：
cmd/main.go
  ↓
snapshotter.NewSnapshotterWithAudit(root, auditLogger)
  ↓
storage.NewDedupStore(root)  ← 硬编码 useFscache=true
  ↓
NewDedupStoreWithOptions(root, useErofs=true, useFscache=true)
  ├─ 初始化 erofsBuilder
  ├─ 初始化 mountManager
  ├─ if useFscache == true:
  │   └─ fscache.NewDedupDaemon()  ← 创建 Fscache 模式
  │       └─ NewBackend() → syscall 调用内核 fscache
  │       └─ startWorkers() → 启动 downloadWorker
  │
  └─ (实际上 LazyLoader 也被初始化了，但不会使用)

容器运行时：
snapshotter.Prepare() → snapshotter.Mounts()
  ↓
storage.Mounts(id, parents)
  ↓
if useFscache && dedupDaemon != nil:
  └─ MountErofsWithFscache() → 内核 fscache 模式
     └─ mount -t erofs -o "fsid=...,domain=dedup-snapshotter"

else:
  └─ MountErofs() → LazyLoader 或普通 loop 模式
     └─ 设置 loop 设备 + mount -t erofs
```

---

## Fscache 模式详解

### 工作原理（内核 5.15+）

```
1. 初始化阶段
   ├─ Backend.NewBackend()
   │  ├─ 打开 /dev/cachefiles 设备
   │  └─ 发送 "bind /var/cache/fscache" 命令给内核
   │
   ├─ DedupDaemon.startWorkers()
   │  └─ 启动 N 个 downloadWorker goroutines
   │
   └─ Prefetcher 初始化
      └─ 准备好接收预取任务

2. 挂载阶段
   ├─ MountErofsWithFscache(imageID, fsid, domain)
   │  └─ mount -t erofs -o ro,fsid=<imageID>,domain=dedup-snapshotter none /mnt/point
   │
   └─ 内核在 fscache 中为该 fsid 创建卷

3. 文件访问阶段
   ├─ 容器进程访问文件
   │
   ├─ 内核检查 fscache
   │  ├─ 缓存命中 → 零拷贝读取（完全内核态）
   │  └─ 缓存缺失 → 陷出到用户态，调用 dedupd
   │
   ├─ dedupd downloadWorker 处理请求
   │  ├─ 从 Registry 下载数据
   │  ├─ 通过 fscache 写入缓存文件
   │  └─ 通知内核请求已完成
   │
   └─ 内核唤醒容器进程，提供数据
```

### 关键文件

- **backend.go (311行)**: 直接与 /dev/cachefiles 交互
  - `NewBackend()`: 初始化 fscache 后端
  - `bindCache()`: 将缓存目录与 fscache 绑定
  - `CreateVolume()`: 为镜像创建卷
  - `CreateObject()`: 创建可缓存对象

- **dedupd.go (350行)**: 守护进程实现
  - `NewDedupDaemon()`: 初始化守护进程
  - `downloadWorker()`: 处理下载任务（后台线程）
  - `processDownloadTask()`: 从 Registry 拉取数据

- **prefetch.go (306行)**: 预取管理
  - `StartPrefetch()`: 启动预取任务
  - `runPrefetchJob()`: 执行预取（多线程）
  - `updatePredictor()`: 学习访问模式

---

## LazyLoader 模式详解

### 工作原理

```
1. 初始化阶段
   ├─ LazyLoader.NewLazyLoader(root, registry)
   │  ├─ 创建 lazy-cache/ 目录
   │  └─ startPrefetchWorkers() → 启动 N 个 prefetchWorker
   │
   └─ prefetchQueue 初始化

2. 挂载阶段
   ├─ MountErofs(imageID, imagePath)
   │  ├─ 创建 loop 设备
   │  └─ mount -t erofs /dev/loopN /mnt/point
   │
   └─ 镜像作为普通 EROFS 文件系统挂载

3. 文件访问阶段
   ├─ 容器进程访问文件
   │
   ├─ VFS 检查 page cache
   │  ├─ 缓存命中 → 从 page cache 读取
   │  └─ 缓存缺失 → 从 lazy-cache/ 或 Registry 读取
   │
   └─ LazyLoader.LoadChunk()
      ├─ 检查本地缓存
      ├─ 如果缺失，从 Registry 下载
      └─ 保存到 lazy-cache/

4. 预取阶段（可选）
   ├─ Prefetch() 添加任务到预取队列
   └─ prefetchWorker 后台执行
      ├─ 下载数据
      └─ 保存到 lazy-cache/
```

### 关键文件

- **loader.go (273行)**: 核心实现
  - `NewLazyLoader()`: 初始化
  - `LoadChunk()`: 按需加载
  - `loadChunk()`: 内部实现
  - `fetchChunk()`: HTTP 下载
  - `Prefetch()`: 预取接口
  - `prefetchWorker()`: 后台预取线程

- **internal/lazy/loader.go (72行)**: 通用接口
  - `Loader` 结构体
  - `Fetcher` 接口
  - `Load()` 方法

---

## 模式选择逻辑

### 关键代码位置

**pkg/storage/dedup.go 第 49-51 行**：
```go
func NewDedupStore(root string) (*DedupStore, error) {
    return NewDedupStoreWithOptions(root, true, true)
    // 硬编码 useErofs=true, useFscache=true
}
```

**pkg/storage/dedup.go 第 100-114 行**：
```go
if useFscache {
    dedupDaemon, err := fscache.NewDedupDaemon(root, "", 4)
    if err != nil {
        log.L.Warnf("failed to create dedupd daemon: %v", err)
        // warn 级别，不影响初始化
    } else {
        store.dedupDaemon = dedupDaemon
    }
} else {
    lazyLoader, err := lazy.NewLazyLoader(root, "")
    if err != nil {
        return nil, fmt.Errorf("failed to create lazy loader: %w", err)
        // error 级别，会失败
    }
    store.lazyLoader = lazyLoader
}
```

**pkg/storage/dedup.go 第 188-198 行**：
```go
if d.useFscache && d.dedupDaemon != nil {
    fsid := parent
    domain := "dedup-snapshotter"
    mountPath, err = d.mountManager.MountErofsWithFscache(parent, fsid, domain)
    if err != nil {
        log.L.Warnf("fscache mount failed, falling back to loop mount: %v", err)
        mountPath, err = d.mountManager.MountErofs(parent, imagePath)
    }
} else {
    mountPath, err = d.mountManager.MountErofs(parent, imagePath)
}
```

### 执行流程决策树

```
运行时决策点：
1. useFscache=true && dedupDaemon!=nil
   ├─ Y: 尝试 MountErofsWithFscache()
   │   ├─ 成功 → Fscache 模式完全运行
   │   └─ 失败 → 降级到 loop mount + dedupd workers
   └─ N: 直接使用 MountErofs() + LazyLoader

注意：
- dedupDaemon 是可选的（初始化失败只 warn）
- LazyLoader 虽然总是初始化，但在 Fscache 模式下不使用
- 挂载时有自动 fallback 机制
```

---

## 配置管理

### 定义位置：pkg/config/config.go

```go
type Config struct {
    EnableErofs   bool          // 第14行
    EnableFscache bool          // 第15行
    EnableLazy    bool          // 第16行
    // ...其他字段
}

DefaultConfig() 默认值：
    EnableErofs:   true
    EnableFscache: true
    EnableLazy:    true
```

### 问题

**配置定义了 EnableFscache 和 EnableLazy，但 dedup.go 中没有使用这些值！**

- 第50行硬编码 `useFscache=true`
- 配置文件的这两个字段实际上被忽略了

---

## 快速对比表

| 特性 | Fscache | LazyLoader |
|------|---------|-----------|
| **内核需求** | 5.15+ | 任意版本 |
| **依赖** | /dev/cachefiles | 无 |
| **缓存位置** | 内核 fscache | 本地文件系统 |
| **多容器共享** | 自动共享页面 | 需手动同步 |
| **性能** | 零拷贝（最优） | VFS + page cache |
| **实现复杂度** | 较复杂 | 较简单 |
| **初始化失败影响** | warn，不影响运行 | error，导致启动失败 |
| **预取接口** | StartPrefetch(ctx, imageID, traceFile) | Prefetch(imageID, hashes) |

---

## 建议

1. **使用 Fscache 作为优先方案**
   - 内核态实现，性能最优
   - 支持容器间缓存共享

2. **修复硬编码问题**
   - 让 NewDedupStore() 从配置读取 useFscache 值
   - 根据配置决定是否初始化 LazyLoader

3. **统一预取接口**
   - 考虑定义通用的预取抽象接口
   - 避免应用层代码针对不同模式编写不同逻辑

4. **改进错误处理**
   - Fscache 初始化失败时考虑是否需要自动 fallback
   - 目前只是 warn，可能导致隐藏的问题

---

## 文件清单

### Fscache 实现
- `/home/clg/dedup/dedup-snapshotter/pkg/fscache/backend.go` (311 行)
- `/home/clg/dedup/dedup-snapshotter/pkg/fscache/dedupd.go` (350 行)
- `/home/clg/dedup/dedup-snapshotter/pkg/fscache/prefetch.go` (306 行)
- `/home/clg/dedup/dedup-snapshotter/pkg/erofs/mount.go` (L101-133)

### LazyLoader 实现
- `/home/clg/dedup/dedup-snapshotter/pkg/lazy/loader.go` (273 行)
- `/home/clg/dedup/dedup-snapshotter/internal/lazy/loader.go` (72 行)

### 模式选择
- `/home/clg/dedup/dedup-snapshotter/pkg/storage/dedup.go` (L100-114, L188-198)

### 配置管理
- `/home/clg/dedup/dedup-snapshotter/pkg/config/config.go` (178 行)

### 命令行工具
- `/home/clg/dedup/dedup-snapshotter/cmd/main.go` (218 行)
- `/home/clg/dedup/dedup-snapshotter/cmd/dedupd/main.go` (135 行) - Fscache 守护进程

