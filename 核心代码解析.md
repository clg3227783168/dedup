# Dedup-Snapshotter 核心代码解析

## 目录结构

```
dedup-snapshotter/
├── cmd/
│   ├── main.go              # 主服务入口
│   └── dedupd/main.go       # 预取守护进程
├── pkg/
│   ├── snapshotter/         # Snapshotter 接口实现
│   │   └── snapshotter.go   # 实现 containerd snapshotter 接口
│   ├── storage/             # 存储层
│   │   ├── dedup.go         # 去重存储核心逻辑
│   │   └── mount.go         # 挂载管理
│   ├── erofs/               # EROFS 构建
│   │   └── builder.go       # 构建 EROFS 镜像
│   ├── fscache/             # Fscache 按需加载
│   │   ├── backend.go       # Fscache 后端
│   │   └── daemon.go        # 预取守护进程
│   ├── lazy/                # 懒加载实现
│   │   └── loader.go        # LazyLoader
│   ├── memory/              # 内存去重
│   │   └── dedup.go         # KSM 集成
│   ├── config/              # 配置管理
│   ├── api/                 # HTTP API
│   ├── audit/               # 审计日志
│   └── metrics/             # 指标收集
└── scripts/
    └── install.sh           # 安装脚本
```

---

## 核心代码分析

### 1. 主入口 - cmd/main.go

**关键流程:**

```go
func main() {
    // 1. 加载配置
    cfg := config.LoadConfig("/etc/dedup-snapshotter/config.json")

    // 2. 创建 Snapshotter
    sn := snapshotter.NewSnapshotterWithAudit(root, auditLogger)

    // 3. 启动 gRPC 服务
    rpc := grpc.NewServer()
    service := snapshotservice.FromSnapshotter(sn)
    snapshotsapi.RegisterSnapshotsServer(rpc, service)

    // 4. 监听 Unix Socket
    l.Listen("unix", "/run/containerd/dedup-snapshotter.sock")
    rpc.Serve(l)
}
```

**位置:** dedup-snapshotter/cmd/main.go:33-175

**说明:**
- 创建 gRPC 服务器,监听 Unix Socket
- Containerd 通过这个 socket 与 snapshotter 通信
- 实现了 containerd snapshotter v1 API

---

### 2. Snapshotter 接口实现 - pkg/snapshotter/snapshotter.go

#### 2.1 Prepare - 准备快照

```go
func (s *Snapshotter) Prepare(ctx context.Context, key, parent string, opts ...snapshots.Opt) ([]mount.Mount, error) {
    // 1. 创建事务
    ctx, t := s.ms.TransactionContext(ctx, true)

    // 2. 在元数据存储中创建快照记录
    snap := storage.CreateSnapshot(ctx, snapshots.KindActive, key, parent, opts...)

    // 3. 调用存储层准备快照
    s.storage.Prepare(ctx, snap.ID, snap.ParentIDs)

    // 4. 提交事务
    t.Commit()

    // 5. 返回挂载信息
    return s.mounts(snap)
}
```

**位置:** dedup-snapshotter/pkg/snapshotter/snapshotter.go:130-145

**说明:**
- Containerd 拉取镜像层时调用此方法
- 创建快照并准备文件系统

---

#### 2.2 Mounts - 返回挂载点

```go
func (s *Snapshotter) Mounts(ctx context.Context, key string) ([]mount.Mount, error) {
    // 1. 标记为活跃挂载
    s.activeMounts[key] = true

    // 2. 获取快照信息
    snap := storage.GetSnapshot(ctx, key)

    // 3. 调用存储层生成挂载配置
    return s.storage.Mounts(snap.ID, snap.ParentIDs)
}
```

**位置:** dedup-snapshotter/pkg/snapshotter/snapshotter.go:111-128

**说明:**
- 返回 overlay 挂载配置
- 包含 lowerdir (EROFS 镜像), upperdir, workdir

---

### 3. 核心存储层 - pkg/storage/dedup.go

#### 3.1 数据结构

```go
type DedupStore struct {
    root        string               // 数据根目录
    db          *sql.DB              // SQLite 索引数据库
    chunkSize   int64                // 块大小 (4MB)
    erofsBuilder *erofs.Builder      // EROFS 构建器
    mountMgr    *MountManager        // 挂载管理器
    memDedup    *memory.Deduplicator // 内存去重
}
```

#### 3.2 Prepare - 准备快照存储

```go
func (s *DedupStore) Prepare(ctx context.Context, id string, parents []string) error {
    // 1. 创建快照目录
    snapshotDir := filepath.Join(s.root, "snapshots", id)
    os.MkdirAll(snapshotDir, 0755)

    // 2. 处理父层
    for _, parent := range parents {
        // 2.1 检查是否有 EROFS 镜像
        erofsImage := filepath.Join(s.root, "images", parent+".erofs")

        if fileExists(erofsImage) {
            // 已有 EROFS 镜像,跳过
            continue
        }

        // 2.2 构建 EROFS 镜像 (带去重)
        sourceDir := filepath.Join(s.root, "snapshots", parent)
        s.buildImageWithDedup(ctx, sourceDir, parent)
    }

    return nil
}
```

**说明:**
- 为每个快照创建目录
- 对父层构建 EROFS 镜像
- 构建过程中进行数据去重

---

#### 3.3 buildImageWithDedup - 构建镜像并去重

```go
func (s *DedupStore) buildImageWithDedup(ctx context.Context, sourceDir, imageID string) error {
    // 1. 遍历源目录所有文件
    filepath.Walk(sourceDir, func(path string, info os.FileInfo, err error) error {
        if info.IsDir() {
            return nil
        }

        // 2. 判断文件大小
        if info.Size() >= s.chunkSize {
            // 大文件: 块级去重
            s.deduplicateFile(path, imageID)
        } else {
            // 小文件: 直接复制
            s.copyFile(path, imageID)
        }
        return nil
    })

    // 3. 构建 EROFS 镜像
    erofsPath := filepath.Join(s.root, "images", imageID+".erofs")
    s.erofsBuilder.BuildImage(sourceDir, erofsPath)

    return nil
}
```

**说明:**
- 小于 4MB 的文件直接复制
- 大于 4MB 的文件进行块级切分和去重

---

#### 3.4 deduplicateFile - 文件块级去重

```go
func (s *DedupStore) deduplicateFile(filePath string, imageID string) error {
    f, _ := os.Open(filePath)
    defer f.Close()

    var chunkHashes []string
    buffer := make([]byte, s.chunkSize) // 4MB 缓冲区

    // 1. 切分文件为 4MB 块
    for {
        n, err := f.Read(buffer)
        if n == 0 {
            break
        }

        // 2. 计算块的 SHA256 哈希
        hash := sha256.Sum256(buffer[:n])
        hashStr := hex.EncodeToString(hash[:])
        chunkHashes = append(chunkHashes, hashStr)

        // 3. 检查块是否已存在
        var exists bool
        s.db.QueryRow("SELECT 1 FROM chunks WHERE hash = ?", hashStr).Scan(&exists)

        if exists {
            // 4a. 块已存在: 增加引用计数
            s.db.Exec("UPDATE chunks SET ref_count = ref_count + 1 WHERE hash = ?", hashStr)
            log.Infof("chunk %s already exists, ref_count++", hashStr[:8])
        } else {
            // 4b. 新块: 存储到 chunks 目录
            chunkPath := filepath.Join(s.root, "chunks", hashStr)
            os.WriteFile(chunkPath, buffer[:n], 0644)

            // 插入数据库记录
            s.db.Exec("INSERT INTO chunks (hash, size, ref_count) VALUES (?, ?, 1)",
                hashStr, n)
            log.Infof("new chunk %s stored, size=%d", hashStr[:8], n)
        }
    }

    // 5. 记录文件到块的映射
    s.db.Exec("INSERT INTO files (path, chunks) VALUES (?, ?)",
        filePath, strings.Join(chunkHashes, ","))

    return nil
}
```

**位置:** dedup-snapshotter/pkg/storage/ (逻辑分布在多个文件)

**说明:**
- **块切分**: 文件按 4MB 大小切分
- **哈希计算**: 使用 SHA256 计算块指纹
- **去重检查**: 查询 index.db 判断块是否已存在
- **引用计数**: 复用已存在的块,增加 ref_count
- **存储优化**: 相同的块只存储一次

---

### 4. EROFS 构建 - pkg/erofs/builder.go

```go
type Builder struct {
    mkfsPath string // mkfs.erofs 工具路径
}

func (b *Builder) BuildImage(sourceDir, outputPath string) error {
    // 1. 执行 mkfs.erofs 命令
    cmd := exec.Command(b.mkfsPath,
        "-zlz4hc,9",              // LZ4HC 压缩,级别9
        "-E", "dedupe",           // 启用去重
        "-E", "ztailpacking",     // 尾部打包优化
        outputPath,               // 输出镜像路径
        sourceDir,                // 源目录
    )

    // 2. 执行构建
    output, err := cmd.CombinedOutput()
    if err != nil {
        return fmt.Errorf("mkfs.erofs failed: %v, output: %s", err, output)
    }

    log.Infof("EROFS image built: %s, size=%d", outputPath, fileSize(outputPath))
    return nil
}
```

**说明:**
- 使用 `mkfs.erofs` 构建只读文件系统镜像
- **LZ4HC 压缩**: 高压缩比,快速解压
- **dedupe**: EROFS 内部去重
- **ztailpacking**: 尾部打包,进一步节省空间

---

### 5. 挂载管理 - pkg/storage/mount.go

```go
func (m *MountManager) Mounts(id string, parents []string) ([]mount.Mount, error) {
    var lowerDirs []string

    // 1. 处理所有父层
    for _, parent := range parents {
        erofsImage := filepath.Join(m.root, "images", parent+".erofs")

        if fileExists(erofsImage) {
            // 2. 挂载 EROFS 镜像
            mountPoint := m.mountErofs(erofsImage, parent)
            lowerDirs = append(lowerDirs, mountPoint)

            // 3. 启动内存去重
            if m.memDedup != nil {
                go m.memDedup.DeduplicateDirectory(mountPoint)
            }
        } else {
            // 降级: 使用传统目录
            lowerDirs = append(lowerDirs, filepath.Join(m.root, "snapshots", parent))
        }
    }

    // 4. 构建 overlay 挂载配置
    upperDir := filepath.Join(m.root, "snapshots", id)
    workDir := filepath.Join(m.root, "work", id)

    return []mount.Mount{
        {
            Type: "overlay",
            Source: "overlay",
            Options: []string{
                "lowerdir=" + strings.Join(lowerDirs, ":"),
                "upperdir=" + upperDir,
                "workdir=" + workDir,
            },
        },
    }, nil
}
```

**说明:**
- 将 EROFS 镜像挂载为 lowerdir
- 使用 overlay 文件系统组合多层
- 启动内存去重线程

---

#### 5.1 mountErofs - 挂载 EROFS

```go
func (m *MountManager) mountErofs(imagePath, id string) string {
    mountPoint := filepath.Join(m.root, "mounts", id)
    os.MkdirAll(mountPoint, 0755)

    if m.fscacheEnabled && m.fscacheBackend != nil {
        // 模式A: Fscache 挂载 (按需加载)
        return m.mountErofsWithFscache(imagePath, mountPoint, id)
    } else {
        // 模式B: 传统 loop 设备挂载
        return m.mountErofsWithLoop(imagePath, mountPoint)
    }
}

func (m *MountManager) mountErofsWithFscache(imagePath, mountPoint, id string) string {
    // 1. 创建 fscache volume
    volume := m.fscacheBackend.CreateVolume(id)

    // 2. 注册镜像到 fscache daemon
    m.daemon.RegisterImage(id, imagePath)

    // 3. 挂载 EROFS with fscache
    cmd := exec.Command("mount", "-t", "erofs",
        "-o", fmt.Sprintf("fsid=%s,domain=dedup-snapshotter", id),
        imagePath, mountPoint)
    cmd.Run()

    // 4. 启动预取任务
    if m.prefetchEnabled {
        go m.startPrefetch(id)
    }

    return mountPoint
}

func (m *MountManager) mountErofsWithLoop(imagePath, mountPoint string) string {
    // 传统 loop 设备挂载
    cmd := exec.Command("mount", "-t", "erofs", "-o", "loop,ro",
        imagePath, mountPoint)
    cmd.Run()

    return mountPoint
}
```

**说明:**
- **Fscache 模式**: 内核级按需加载,高性能
- **Loop 模式**: 降级方案,兼容旧内核
- **预取**: 根据 trace 文件预取热点数据

---

### 6. 按需加载 - pkg/fscache/daemon.go

```go
type DedupDaemon struct {
    backend      *FscacheBackend     // Fscache 后端
    registry     string               // Registry URL
    workers      int                  // 下载工作线程数
    downloadQueue chan *DownloadTask  // 下载队列
    images       map[string]*ImageInfo // 已注册的镜像
}

func (d *DedupDaemon) RegisterImage(imageID, imagePath string) error {
    // 1. 解析镜像 manifest
    manifest := d.parseManifest(imagePath)

    // 2. 注册到 fscache
    d.backend.RegisterImage(imageID, manifest)

    // 3. 加载预取 trace 文件
    traceFile := filepath.Join(d.root, "traces", imageID+".trace")
    if fileExists(traceFile) {
        d.loadPrefetchTrace(imageID, traceFile)
    }

    d.images[imageID] = &ImageInfo{
        ID: imageID,
        Manifest: manifest,
    }

    return nil
}

func (d *DedupDaemon) loadPrefetchTrace(imageID, traceFile string) {
    // 1. 读取 trace 文件 (块哈希列表)
    hashes := readLines(traceFile)

    // 2. 将块加入下载队列
    for _, hash := range hashes {
        d.downloadQueue <- &DownloadTask{
            ImageID: imageID,
            ChunkHash: hash,
            Priority: HIGH, // 预取任务高优先级
        }
    }

    log.Infof("prefetch %d chunks for image %s", len(hashes), imageID)
}

// 下载工作线程
func (d *DedupDaemon) downloadWorker() {
    for task := range d.downloadQueue {
        // 1. 从 registry 下载块
        chunkData := d.downloadChunkFromRegistry(task.ChunkHash)

        // 2. 写入 fscache
        d.backend.WriteObject(task.ImageID, task.ChunkHash, chunkData)

        // 3. 标记对象完成
        d.backend.MarkObjectComplete(task.ImageID, task.ChunkHash)
    }
}
```

**位置:** dedup-snapshotter/pkg/fscache/daemon.go:1-135

**说明:**
- **镜像注册**: 容器启动时注册镜像到 daemon
- **预取队列**: 根据 trace 文件预取热点数据
- **并发下载**: 多个 worker 并发下载块
- **Fscache 集成**: 下载的数据直接写入内核缓存

---

### 7. 内存去重 - pkg/memory/dedup.go

```go
type Deduplicator struct {
    pageSize    int                  // 页大小 (4KB)
    pageMap     map[string]*PageInfo // 页面映射
    ksmEnabled  bool                 // KSM 是否启用
}

type PageInfo struct {
    Hash      string   // 页面哈希
    RefCount  int      // 引用计数
    Addresses []uintptr // 内存地址列表
}

func (d *Deduplicator) DeduplicateFile(filePath string) error {
    // 1. mmap 文件到内存
    f, _ := os.Open(filePath)
    data, _ := syscall.Mmap(int(f.Fd()), 0, fileSize,
        syscall.PROT_READ, syscall.MAP_SHARED)
    defer syscall.Munmap(data)

    // 2. 按页面 (4KB) 处理
    for offset := 0; offset < len(data); offset += d.pageSize {
        page := data[offset:offset+d.pageSize]

        // 3. 计算页面哈希
        hash := sha256.Sum256(page)
        hashStr := hex.EncodeToString(hash[:])

        // 4. 检查是否已存在
        if pageInfo, exists := d.pageMap[hashStr]; exists {
            // 页面已存在,增加引用计数
            pageInfo.RefCount++
            log.Debugf("page %s duplicated, ref_count=%d", hashStr[:8], pageInfo.RefCount)
        } else {
            // 新页面,记录
            d.pageMap[hashStr] = &PageInfo{
                Hash: hashStr,
                RefCount: 1,
                Addresses: []uintptr{uintptr(unsafe.Pointer(&page[0]))},
            }
        }
    }

    // 5. 标记内存区域可合并 (KSM)
    if d.ksmEnabled {
        syscall.Madvise(data, syscall.MADV_MERGEABLE)
    }

    return nil
}

func (d *Deduplicator) EnableKSM() error {
    // 启用 KSM 内核模块
    os.WriteFile("/sys/kernel/mm/ksm/run", []byte("1"), 0644)

    // 配置扫描参数
    os.WriteFile("/sys/kernel/mm/ksm/sleep_millisecs", []byte("100"), 0644)
    os.WriteFile("/sys/kernel/mm/ksm/pages_to_scan", []byte("100"), 0644)

    d.ksmEnabled = true
    return nil
}
```

**位置:** dedup-snapshotter/pkg/memory/dedup.go:1-200

**说明:**
- **页面级去重**: 4KB 页面粒度
- **内存映射**: 使用 mmap 映射文件到内存
- **KSM 集成**: 调用 madvise(MADV_MERGEABLE) 标记可合并页面
- **内核合并**: KSM 后台扫描并合并相同页面

---

## 关键数据流

### 完整的镜像拉取流程

```
用户执行: ctr image pull --snapshotter=dedup nginx:latest
    ↓
Containerd 从 Registry 拉取 manifest 和 layers
    ↓
对每一层调用: Snapshotter.Prepare(layerID, parentLayerID)
    ↓
DedupStore.Prepare():
    ├─ 创建快照目录: /var/lib/.../snapshots/<layerID>/
    ├─ 检查父层是否有 EROFS 镜像
    └─ 没有 → 构建 EROFS 镜像并去重
        ↓
    buildImageWithDedup():
        ├─ 遍历所有文件
        ├─ 小文件 (<4MB): 直接复制
        └─ 大文件 (≥4MB): 块级去重
            ↓
        deduplicateFile():
            ├─ 切分为 4MB 块
            ├─ 计算 SHA256 哈希
            ├─ 查询 chunks 表
            ├─ 存在 → ref_count++
            ├─ 不存在 → 存储到 chunks/ 并插入记录
            └─ 记录文件到块的映射
            ↓
    erofsBuilder.BuildImage():
        ├─ 执行 mkfs.erofs
        ├─ LZ4HC 压缩
        └─ 生成 <layerID>.erofs
    ↓
Containerd 调用: Snapshotter.Mounts(layerID)
    ↓
MountManager.Mounts():
    ├─ 遍历所有父层
    ├─ 挂载 EROFS 镜像
    │   ├─ Fscache 模式: mountErofsWithFscache()
    │   │   ├─ 创建 fscache volume
    │   │   ├─ 注册到 dedupd daemon
    │   │   └─ mount -t erofs -o fsid=...
    │   └─ Loop 模式: mountErofsWithLoop()
    │       └─ mount -t erofs -o loop,ro
    ├─ 构建 overlay 挂载配置
    └─ 启动内存去重
        ↓
返回挂载点给 Containerd
    ↓
容器启动,文件系统就绪
    ↓
容器访问文件 (按需加载触发)
    ↓
Fscache 内核模块检测到缺失的数据块
    ↓
Dedupd Daemon 从 Registry 下载块
    ↓
写入 fscache,提供给容器
    ↓
容器继续运行 ✓
```

---

## 性能优化技术

### 1. 块级去重
- **4MB 块大小**: 平衡去重率和性能
- **SHA256 哈希**: 快速且冲突概率极低
- **引用计数**: 跟踪块的使用情况

### 2. EROFS 优化
- **只读文件系统**: 消除写入开销
- **LZ4HC 压缩**: 高压缩比,快速解压
- **Tail Packing**: 小文件尾部打包,减少碎片

### 3. 按需加载
- **Fscache 内核集成**: 零拷贝,低延迟
- **预取优化**: 基于 trace 文件的智能预取
- **并发下载**: 多 worker 并行下载

### 4. 内存去重
- **KSM 集成**: 内核级页面合并
- **页面级粒度**: 4KB 页面去重
- **自动合并**: 内核后台自动扫描

---

## 数据库 Schema

### index.db (SQLite)

```sql
-- 数据块索引
CREATE TABLE chunks (
    hash TEXT PRIMARY KEY,       -- SHA256 哈希
    size INTEGER NOT NULL,       -- 块大小 (字节)
    ref_count INTEGER DEFAULT 1, -- 引用计数
    created_at INTEGER           -- 创建时间戳
);

-- 文件到块映射
CREATE TABLE files (
    path TEXT PRIMARY KEY,       -- 文件路径
    chunks TEXT NOT NULL,        -- 块哈希列表 (逗号分隔)
    total_size INTEGER,          -- 文件总大小
    created_at INTEGER           -- 创建时间戳
);

-- 镜像元数据
CREATE TABLE images (
    image_id TEXT PRIMARY KEY,   -- 镜像 ID
    erofs_path TEXT,             -- EROFS 镜像路径
    size INTEGER,                -- 镜像大小
    created_at INTEGER           -- 创建时间戳
);

-- 索引
CREATE INDEX idx_chunks_refcount ON chunks(ref_count);
CREATE INDEX idx_files_size ON files(total_size);
```

### audit.db (SQLite)

```sql
-- 审计日志
CREATE TABLE audit_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp INTEGER,           -- 时间戳
    operation TEXT,              -- 操作类型
    target TEXT,                 -- 操作目标
    user TEXT,                   -- 用户
    pid INTEGER,                 -- 进程 ID
    result TEXT,                 -- 结果 (success/failure)
    metadata TEXT,               -- 元数据 (JSON)
    error TEXT                   -- 错误信息
);

CREATE INDEX idx_audit_timestamp ON audit_logs(timestamp);
CREATE INDEX idx_audit_operation ON audit_logs(operation);
```

---

## 配置文件详解

```json
{
  "root": "/var/lib/containerd/io.containerd.snapshotter.v1.dedup",
  "enable_erofs": true,          // 启用 EROFS
  "enable_fscache": true,        // 启用 fscache (需内核支持)
  "enable_lazy": true,           // 启用按需加载
  "enable_mem_dedup": true,      // 启用内存去重
  "registry": "",                // Registry URL (默认为空)
  "chunk_size": 4194304,         // 块大小: 4MB
  "log_level": "info",           // 日志级别

  "prefetch": {
    "enabled": true,             // 启用预取
    "workers": 4,                // 预取工作线程数
    "queue_size": 1000,          // 预取队列大小
    "trace_dir": ".../traces"    // Trace 文件目录
  },

  "ksm": {
    "enabled": true,             // 启用 KSM
    "scan_interval": 100,        // 扫描间隔 (ms)
    "pages_to_scan": 100,        // 每次扫描页数
    "merge_across_nodes": false  // 跨 NUMA 节点合并
  },

  "dedupd": {
    "enabled": true,             // 启用 dedupd daemon
    "workers": 4,                // 下载工作线程数
    "registry": "...",           // Registry URL
    "fscache_domain": "dedup-snapshotter" // Fscache 域名
  }
}
```

---

## 总结

### 核心实现要点

1. **Snapshotter 接口** (`pkg/snapshotter/`)
   - 实现 containerd snapshotter v1 API
   - Prepare, Mounts, Commit, Remove

2. **存储层** (`pkg/storage/`)
   - 块级去重 (4MB 块)
   - SHA256 哈希计算
   - SQLite 索引管理

3. **EROFS 构建** (`pkg/erofs/`)
   - mkfs.erofs 封装
   - LZ4HC 压缩
   - Tail Packing 优化

4. **按需加载** (`pkg/fscache/`, `pkg/lazy/`)
   - Fscache 内核集成
   - LazyLoader 用户态实现
   - 智能预取队列

5. **内存去重** (`pkg/memory/`)
   - KSM 集成
   - 页面级去重
   - madvise MADV_MERGEABLE

### 性能关键路径

```
拉取镜像 → 块级去重 → EROFS 构建 → Fscache 挂载 → 按需加载 → 容器启动
```

整个流程通过以下技术实现高性能:
- **增量下载**: 只下载必需的数据块
- **跨镜像去重**: 多个镜像共享相同的块
- **内核级缓存**: Fscache 零拷贝访问
- **智能预取**: 基于访问模式的预取
- **内存去重**: KSM 合并相同的内存页
